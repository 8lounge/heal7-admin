<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="cache-control" content="no-cache, no-store, must-revalidate">
    <meta name="expires" content="0">
    <meta name="build-time" content="2025-07-28-20:00">
    <meta name="cache-buster" content="redis-optimized-v25">
    <title>ëŒ€ê·œëª¨ 3D ìƒíƒœ-ì¸ì§€ ë§¤íŠ¸ë¦­ìŠ¤ (v25: Redis ìºì‹± ìµœì í™”)</title>
    <!-- Tailwind CDN removed to prevent conflicts with Next.js build -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #0c0a09;
        }
        .ui-layer {
            position: absolute;
            background-color: rgba(41, 37, 36, 0.8);
            padding: 1rem;
            border-radius: 0.5rem;
            color: #d6d3d1;
            z-index: 1000;
            backdrop-filter: blur(4px);
            pointer-events: auto;
        }
        .keyword-label {
            color: #e5e7eb;
            font-size: 14px;
            text-shadow: 0 0 8px #000;
            transition: opacity 0.3s, font-size 0.3s;
        }
        #legend {
            bottom: 1.5rem;
            left: 1.5rem;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1001;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 0.5rem; }
        .legend-color { width: 1rem; height: 1rem; border-radius: 50%; margin-right: 0.75rem; border: 1px solid rgba(255,255,255,0.2); }
        
        #search-container {
            top: 1.5rem;
            right: 1.5rem;
            display: flex;
            align-items: center;
            padding: 0.5rem;
            z-index: 1001;
        }
        #keyword-search { background-color: transparent; border: none; border-bottom: 2px solid #6b7280; color: white; padding: 0.25rem 0.5rem; transition: border-color 0.3s; }
        #keyword-search:focus { outline: none; border-bottom-color: #f59e0b; }
        #search-button { background-color: #f59e0b; color: #1c1917; border: none; padding: 0.35rem 0.75rem; border-radius: 0.25rem; margin-left: 0.5rem; cursor: pointer; font-weight: bold; transition: background-color 0.3s; }
        #search-button:hover { background-color: #fbbf24; }

        #controls-container {
            top: 1.5rem;
            left: 1.5rem;
            width: 200px;
            z-index: 1001;
        }
        .control-group { margin-bottom: 0.75rem; }
        .control-group:last-child { margin-bottom: 0; }
        .control-group label { display: block; font-size: 0.875rem; margin-bottom: 0.25rem; }
        .control-group input[type="range"] { width: 100%; }
        .control-group button { width: 100%; background-color: #3f3f46; color: white; border: none; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer; transition: background-color 0.3s; }
        .control-group button:hover { background-color: #52525b; }
        .zoom-buttons button { flex: 1; }
        
        /* 3D ë Œë”ë§ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        #container {
            position: relative;
            z-index: 1;
        }
        
        /* UI ì˜ì—­ì—ì„œ í‚¤ì›Œë“œ í´ë¦­ ì°¨ë‹¨ */
        .ui-block-area {
            position: absolute;
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="legend" class="ui-layer">
        <h3 class="font-bold mb-2 text-white">ìƒíƒœ ìƒ‰ìƒ</h3>
        <div class="legend-item"><div class="legend-color" style="background-color: #4ade80;"></div>ê¸ì •</div>
        <div class="legend-item"><div class="legend-color" style="background-color: #facc15;"></div>ì¤‘ë¦½</div>
        <div class="legend-item"><div class="legend-color" style="background-color: #f87171;"></div>ë¶€ì •</div>
        <div class="legend-item"><div class="legend-color" style="background-color: #6b7280;"></div>ë¹„í™œì„±</div>
    </div>
    <div id="search-container" class="ui-layer">
        <input type="text" id="keyword-search" placeholder="í‚¤ì›Œë“œ ê²€ìƒ‰...">
        <button id="search-button">ê²€ìƒ‰</button>
    </div>
    <div id="controls-container" class="ui-layer">
        <div class="control-group">
            <button id="reset-button">ì´ˆê¸°í™”</button>
        </div>
        <div class="control-group">
            <label for="speed-slider">íšŒì „ ì†ë„</label>
            <input type="range" id="speed-slider" min="0" max="5" step="0.1" value="1.3">
        </div>
        <div class="control-group">
            <label for="text-size-slider">í…ìŠ¤íŠ¸ í¬ê¸°</label>
            <input type="range" id="text-size-slider" min="10" max="24" step="1" value="14">
        </div>
        <div class="control-group">
            <div class="flex gap-3 items-center justify-between">
                <button id="zoom-in-button" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition-all duration-200 text-center">ì¤Œì¸ (+)</button>
                <button id="zoom-out-button" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition-all duration-200 text-center">ì¤Œì•„ì›ƒ (-)</button>
            </div>
        </div>
    </div>
    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, labelRenderer, controls, raycaster, group;
        const nodes = {};
        const edges = [];
        const hitboxes = [];
        const mouse = new THREE.Vector2(-100, -100); // Initialize mouse off-screen
        let cameraTween, targetTween;

        // --- IMPROVED STATE MANAGEMENT ---
        let highlightedNode = null; // Node currently under the mouse
        let isFocused = false;      // Is the camera focused on a node set?
        let isHovering = false;     // Is the mouse currently over a node?
        let hasUserInteracted = false; // Has the user moved the mouse for the first time?

        const initialCameraPosition = new THREE.Vector3(0, 0, 150);

        // ì‹¤ì œ í‚¤ì›Œë“œ ë°ì´í„°ì™€ ì¢…ì†ì„±ì„ APIì—ì„œ ê°€ì ¸ì˜´
        let keywordData = {};
        let keywords = [];
        let dependencies = [];
        let isDataLoaded = false;

        // APIì—ì„œ í‚¤ì›Œë“œì™€ ì¢…ì†ì„± ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (Redis ìºì‹± í†µí•© ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš©)
        async function loadKeywordData() {
            try {
                console.log('Loading keyword matrix data from Redis-cached API...');
                
                // Redis ìºì‹±ëœ í†µí•© ì—”ë“œí¬ì¸íŠ¸ì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const response = await fetch('/admin-api/keywords/matrix/data');
                
                if (!response.ok) {
                    console.warn('Matrix API failed, falling back to separate endpoints...');
                    // í´ë°±: ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ê°œë³„ ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ
                    return await loadKeywordDataFallback();
                }
                
                const matrixData = await response.json();
                
                console.log(`Loaded matrix data from cache: ${matrixData.keywords.length} keywords, ${matrixData.dependencies.length} dependencies`);
                console.log('Cache stats:', matrixData.stats);
                
                // ì „ì—­ ë³€ìˆ˜ì— í• ë‹¹ (ë°±ì—”ë“œì—ì„œ ìµœì í™”ëœ ë°ì´í„° ì§ì ‘ ì‚¬ìš©)
                keywords = matrixData.keywords;
                keywordData = matrixData.keyword_data || {}; // ë°±ì—”ë“œì—ì„œ ì´ë¯¸ ì²˜ë¦¬ëœ ë°ì´í„° ì‚¬ìš©
                
                // ë°±ì—”ë“œì—ì„œ ì „ì²˜ë¦¬ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ ì²˜ë¦¬ (í´ë°±)
                if (!matrixData.keyword_data) {
                    const dependenciesData = matrixData.dependencies;
                    keywordData = {};
                    const keywordMap = new Map();
                    
                    keywords.forEach(keyword => {
                        keywordMap.set(keyword.id, keyword.text);
                        keywordData[keyword.text] = [];
                    });
                    
                    dependenciesData.forEach(dep => {
                        const parentText = keywordMap.get(dep.parent_keyword_id);
                        const dependentText = keywordMap.get(dep.dependent_keyword_id);
                        
                        if (parentText && dependentText) {
                            keywordData[parentText].push(dependentText);
                        }
                    });
                }
                
                isDataLoaded = true;
                console.log('Keyword matrix data loaded successfully from Redis cache');
                
                // ë°ì´í„° ë¡œë“œ ì™„ë£Œ í›„ 3D ì‹œê°í™” ì‹œì‘
                init();
                animate();
                
            } catch (error) {
                console.error('Failed to load keyword matrix data:', error);
                // í´ë°±: ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ê°œë³„ ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ
                return await loadKeywordDataFallback();
            }
        }

        // í´ë°± í•¨ìˆ˜: ê¸°ì¡´ ë°©ì‹ì˜ ê°œë³„ ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ
        async function loadKeywordDataFallback() {
            try {
                console.log('Loading keyword data from separate endpoints (fallback)...');
                
                // í‚¤ì›Œë“œì™€ ì¢…ì†ì„± ë°ì´í„°ë¥¼ ë³‘ë ¬ë¡œ ê°€ì ¸ì˜´
                const [keywordsResponse, dependenciesResponse] = await Promise.all([
                    fetch('/admin-api/keywords/all'),
                    fetch('/admin-api/dependencies/')
                ]);
                
                if (!keywordsResponse.ok || !dependenciesResponse.ok) {
                    throw new Error('Failed to fetch data from fallback APIs');
                }
                
                keywords = await keywordsResponse.json();
                const dependenciesData = await dependenciesResponse.json();
                
                console.log(`Loaded fallback data: ${keywords.length} keywords and ${dependenciesData.length} dependencies`);
                
                // ì¢…ì†ì„± ë°ì´í„°ë¥¼ í‚¤ì›Œë“œ ë§¤í•‘ í˜•íƒœë¡œ ë³€í™˜
                keywordData = {};
                const keywordMap = {};
                
                // í‚¤ì›Œë“œ ID to í…ìŠ¤íŠ¸ ë§¤í•‘ ìƒì„±
                keywords.forEach(keyword => {
                    keywordMap[keyword.id] = keyword.text;
                });
                
                // ì¢…ì†ì„± ë°ì´í„°ë¥¼ í‚¤ì›Œë“œ ë§¤í•‘ìœ¼ë¡œ ë³€í™˜
                dependenciesData.forEach(dep => {
                    const parentText = keywordMap[dep.parent_keyword_id];
                    const dependentText = keywordMap[dep.dependent_keyword_id];
                    
                    if (parentText && dependentText) {
                        if (!keywordData[parentText]) {
                            keywordData[parentText] = [];
                        }
                        keywordData[parentText].push(dependentText);
                    }
                });
                
                // ëª¨ë“  í‚¤ì›Œë“œê°€ í‚¤ì›Œë“œ ë°ì´í„°ì— í¬í•¨ë˜ë„ë¡ ë³´ì¥
                keywords.forEach(keyword => {
                    if (!keywordData[keyword.text]) {
                        keywordData[keyword.text] = [];
                    }
                });
                
                isDataLoaded = true;
                console.log('Keyword data loaded successfully (fallback)');
                
                // ë°ì´í„° ë¡œë“œ ì™„ë£Œ í›„ 3D ì‹œê°í™” ì‹œì‘
                init();
                animate();
                
            } catch (error) {
                console.error('Failed to load keyword data (fallback also failed):', error);
                // ìµœì¢… ì‹¤íŒ¨ ì‹œ ë¹ˆ ë°ì´í„°ë¡œ ì´ˆê¸°í™”
                keywordData = {};
                keywords = [];
                isDataLoaded = true;
                
                // ì—ëŸ¬ ì‹œì—ë„ 3D ì‹œê°í™” ì‹œì‘ (ë¹ˆ ë°ì´í„°ë¡œ)
                init();
                animate();
            }
        }

        function getStateColor(state) {
            if (state > 0.5) return new THREE.Color("#4ade80"); // Positive
            if (state > -0.2) return new THREE.Color("#facc15"); // Neutral
            if (state > -1) return new THREE.Color("#f87171"); // Negative
            return new THREE.Color("#6b7280"); // Inactive
        }

        // ë°ì´í„° ë¡œë“œ í›„ ì´ˆê¸°í™”
        loadKeywordData();

        function init() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.copy(initialCameraPosition);
            raycaster = new THREE.Raycaster();

            group = new THREE.Group();
            scene.add(group);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            container.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 0, 0); // ëª…ì‹œì ìœ¼ë¡œ ì´ˆê¸° íƒ€ê²Ÿ ì„¤ì •
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 300;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.3;

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            createGraph();
            setupUIAndListeners();
        }

        function createGraph() {
            const mainKeywords = Object.keys(keywordData);
            const allKeywords = new Set();
            mainKeywords.forEach(key => {
                allKeywords.add(key);
                if(keywordData[key]) keywordData[key].forEach(dep => allKeywords.add(dep));
            });

            const keywordStates = {};
            allKeywords.forEach(k => keywordStates[k] = (Math.random() * 2 - 1));

            mainKeywords.forEach(mainK => {
                const deps = keywordData[mainK];
                if (deps && deps.length > 0) {
                    const avgState = deps.reduce((acc, depK) => acc + (keywordStates[depK] || 0), 0) / deps.length;
                    keywordStates[mainK] = avgState;
                }
            });

            const sphereRadius = 80;
            const positions = [];
            const numPoints = allKeywords.size;
            for (let i = 0; i < numPoints; i++) {
                const phi = Math.acos(-1 + (2 * i) / numPoints);
                const theta = Math.sqrt(numPoints * Math.PI) * phi;
                positions.push(new THREE.Vector3(
                    sphereRadius * Math.cos(theta) * Math.sin(phi),
                    sphereRadius * Math.sin(theta) * Math.sin(phi),
                    sphereRadius * Math.cos(phi)
                ));
            }
            
            let i = 0;
            allKeywords.forEach(keyword => {
                const isMain = mainKeywords.includes(keyword);
                const state = keywordStates[keyword];
                const color = getStateColor(state);
                
                const geometry = new THREE.SphereGeometry(isMain ? 0.5 : 0.25, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: color, emissive: color.clone().multiplyScalar(0.3), shininess: 80, transparent: true });
                const node = new THREE.Mesh(geometry, material);
                node.position.copy(positions[i++]);
                node.userData = { id: keyword, isNode: true, isMain: isMain, connections: new Set(), waveOffset: Math.random() * Math.PI * 2, originalPosition: node.position.clone(), originalState: state };
                
                const labelDiv = document.createElement('div');
                labelDiv.className = 'keyword-label';
                labelDiv.textContent = keyword;
                labelDiv.style.fontWeight = isMain ? 'bold' : 'normal';
                labelDiv.style.pointerEvents = 'auto'; // ë¼ë²¨ í´ë¦­ í™œì„±í™”
                labelDiv.style.cursor = 'pointer'; // ë§ˆìš°ìŠ¤ ì»¤ì„œ ë³€ê²½
                labelDiv.addEventListener('click', (e) => {
                    e.stopPropagation(); // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ë°©ì§€
                    focusOnSet(node);
                });
                
                const label = new CSS2DObject(labelDiv);
                label.position.set(0, isMain ? 0.8 : 0.5, 0);
                node.add(label);
                node.userData.label = label;
                
                nodes[keyword] = node;
                group.add(node);

                // íˆíŠ¸ë°•ìŠ¤ í¬ê¸°ë¥¼ í‚¤ì›Œë“œ íƒ€ì…ì— ë”°ë¼ ì¡°ì • (ê²¹ì¹¨ ë°©ì§€)
                const hitboxRadius = isMain ? 0.8 : 0.5; // ë©”ì¸ í‚¤ì›Œë“œ: 0.8, ì¼ë°˜ í‚¤ì›Œë“œ: 0.5
                const hitboxGeometry = new THREE.SphereGeometry(hitboxRadius, 8, 8);
                const hitboxMaterial = new THREE.MeshBasicMaterial({ visible: false });
                const hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                hitbox.position.copy(node.position);
                hitbox.userData.visibleNode = node;
                hitbox.userData.keyword = keyword; // ë””ë²„ê¹…ìš© í‚¤ì›Œë“œ ì •ë³´ ì¶”ê°€
                hitboxes.push(hitbox);
                group.add(hitbox);
            });

            let totalConnections = 0;
            let skippedConnections = 0;
            
            mainKeywords.forEach(mainKeyword => {
                const startNode = nodes[mainKeyword];
                if (!startNode) {
                    console.warn(`ë©”ì¸ í‚¤ì›Œë“œ ë…¸ë“œ ì—†ìŒ: ${mainKeyword}`);
                    return;
                }
                if (!keywordData[mainKeyword]) {
                    console.warn(`í‚¤ì›Œë“œ ë°ì´í„° ì—†ìŒ: ${mainKeyword}`);
                    return;
                }

                keywordData[mainKeyword].forEach(depKeyword => {
                    const endNode = nodes[depKeyword];
                    if (!endNode) {
                        console.warn(`ì¢…ì† í‚¤ì›Œë“œ ë…¸ë“œ ì—†ìŒ: ${depKeyword} (ë©”ì¸: ${mainKeyword})`);
                        skippedConnections++;
                        return;
                    }
                    
                    const points = [startNode.position, endNode.position];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ color: 0x4b5563, transparent: true, opacity: 0.15 });
                    const edge = new THREE.Line(geometry, material);
                    edge.userData = { nodes: [startNode, endNode] };
                    edges.push(edge);
                    
                    group.add(edge);
                    
                    startNode.userData.connections.add(endNode);
                    endNode.userData.connections.add(startNode);
                    totalConnections++;
                });
            });
            
            console.log(`ì—°ê²° ìƒì„± ì™„ë£Œ: ì´ ${totalConnections}ê°œ ì—°ê²°, ${skippedConnections}ê°œ ìŠ¤í‚µ`);
        }
        
        function setupUIAndListeners() {
            // Search
            document.getElementById('search-button').addEventListener('click', searchKeyword);
            document.getElementById('keyword-search').addEventListener('keydown', (e) => { if (e.key === 'Enter') searchKeyword(); });
            
            // Controls
            document.getElementById('reset-button').addEventListener('click', resetCamera);
            document.getElementById('speed-slider').addEventListener('input', (e) => { controls.autoRotateSpeed = parseFloat(e.target.value); });
            document.getElementById('text-size-slider').addEventListener('input', (e) => {
                const newSize = e.target.value + 'px';
                Object.values(nodes).forEach(node => { node.userData.label.element.style.fontSize = newSize; });
            });
            document.getElementById('zoom-in-button').addEventListener('click', () => {
                const factor = 0.8;
                camera.position.multiplyScalar(factor);
                controls.update();
            });
            document.getElementById('zoom-out-button').addEventListener('click', () => {
                const factor = 1.2;
                camera.position.multiplyScalar(factor);
                controls.update();
            });

            // --- REFINED EVENT LISTENERS ---
            window.addEventListener('resize', onWindowResize, false);
            // renderer.domElement.addEventListener('mousemove', onMouseMove, false); // ë§ˆìš°ìŠ¤ ë¡¤ì˜¤ë²„ í¬ì»¤ì‹± ë¹„í™œì„±í™”
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            renderer.domElement.addEventListener('wheel', onWheel, false); // For focus deactivation

            // Deactivate focus on drag start
            controls.addEventListener('start', () => {
                if (cameraTween) cameraTween.kill();
                if (targetTween) targetTween.kill();
                controls.enabled = true;

                if (isFocused) {
                    isFocused = false;
                    unhighlightAll();
                    highlightedNode = null;
                    // Gently reset orbit target so rotation is correct after drag
                    gsap.to(controls.target, { duration: 0.5, x: 0, y: 0, z: 0, ease: "power2.out" });
                }
            });
        }
        
        // --- EVENT HANDLER FUNCTIONS ---

        function onWindowResize() {
            console.log(`Window resized: ${window.innerWidth}x${window.innerHeight}`);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            console.log(`Camera aspect after resize: ${camera.aspect}`);
        }

        // ë§ˆìš°ìŠ¤ ë¡¤ì˜¤ë²„ í¬ì»¤ì‹± ê¸°ëŠ¥ ë¹„í™œì„±í™” - í´ë¦­ìœ¼ë¡œë§Œ í¬ì»¤ì‹±
        // function onMouseMove(event) {
        //     // This flag ensures hover effects only start after the user first moves the mouse.
        //     if (!hasUserInteracted) {
        //         hasUserInteracted = true;
        //     }
        //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        // }

        function onCanvasClick(event) {
            // UI ì˜ì—­ í´ë¦­ ì°¨ë‹¨ - UI ìš”ì†Œë“¤ê³¼ì˜ ì¶©ëŒ ì²´í¬
            const uiElements = [
                document.getElementById('controls-container'),
                document.getElementById('search-container'),
                document.getElementById('legend')
            ];
            
            // í´ë¦­ ìœ„ì¹˜ê°€ UI ì˜ì—­ì— ìˆëŠ”ì§€ í™•ì¸
            for (let uiElement of uiElements) {
                if (uiElement) {
                    const rect = uiElement.getBoundingClientRect();
                    if (event.clientX >= rect.left && event.clientX <= rect.right &&
                        event.clientY >= rect.top && event.clientY <= rect.bottom) {
                        console.log('UI ì˜ì—­ í´ë¦­ ê°ì§€ - í‚¤ì›Œë“œ í´ë¦­ ì°¨ë‹¨:', uiElement.id);
                        return; // UI ì˜ì—­ í´ë¦­ì´ë¯€ë¡œ í‚¤ì›Œë“œ í´ë¦­ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
                    }
                }
            }
            
            // í´ë¦­ ì‹œ ë§ˆìš°ìŠ¤ ì¢Œí‘œ ì—…ë°ì´íŠ¸
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitboxes);

            if (intersects.length > 0) {
                // ê°€ì¥ ê°€ê¹Œìš´ íˆíŠ¸ë°•ìŠ¤ ì„ íƒ (ê±°ë¦¬ ê¸°ì¤€ ì •ë ¬ì€ ì´ë¯¸ ë˜ì–´ ìˆìŒ)
                const closestIntersect = intersects[0];
                const clickedNode = closestIntersect.object.userData.visibleNode;
                const clickedKeyword = clickedNode.userData.id;
                
                // ë””ë²„ê¹…: í´ë¦­ ì •í™•ë„ ê²€ì¦
                console.log(`=== í´ë¦­ ë””ë²„ê¹… ===`);
                console.log(`ë§ˆìš°ìŠ¤ ì¢Œí‘œ: (${mouse.x.toFixed(3)}, ${mouse.y.toFixed(3)})`);
                console.log(`ê°ì§€ëœ íˆíŠ¸ë°•ìŠ¤ ê°œìˆ˜: ${intersects.length}`);
                console.log(`ì„ íƒëœ í‚¤ì›Œë“œ: "${clickedKeyword}"`);
                console.log(`ì„ íƒëœ ê±°ë¦¬: ${closestIntersect.distance.toFixed(2)}`);
                
                // ê²¹ì¹œ í‚¤ì›Œë“œê°€ ìˆëŠ” ê²½ìš° ìƒìœ„ 3ê°œ ì¶œë ¥
                if (intersects.length > 1) {
                    console.log(`ê²¹ì¹œ í‚¤ì›Œë“œë“¤ (ê±°ë¦¬ìˆœ):`);
                    intersects.slice(0, 3).forEach((intersect, index) => {
                        const nodeKeyword = intersect.object.userData.visibleNode.userData.id;
                        const distance = intersect.distance.toFixed(2);
                        const isMain = intersect.object.userData.visibleNode.userData.isMain;
                        console.log(`  ${index + 1}. "${nodeKeyword}" (ê±°ë¦¬: ${distance}) ${isMain ? '[ë©”ì¸]' : '[ì¼ë°˜]'}`);
                    });
                    
                    // ë§Œì•½ ë§¤ìš° ê°€ê¹Œìš´ ê±°ë¦¬ì— ì—¬ëŸ¬ í‚¤ì›Œë“œê°€ ìˆë‹¤ë©´ ê²½ê³ 
                    const distanceDiff = intersects[1].distance - intersects[0].distance;
                    if (distanceDiff < 0.1) {
                        console.warn(`âš ï¸ ë§¤ìš° ê°€ê¹Œìš´ í‚¤ì›Œë“œë“¤ì´ ê²¹ì¹¨ (ê±°ë¦¬ ì°¨ì´: ${distanceDiff.toFixed(3)})`);
                    }
                }
                
                // Only focus on click
                focusOnSet(clickedNode);
            } else {
                console.log(`ë¹ˆ ê³µê°„ í´ë¦­ - íˆíŠ¸ë°•ìŠ¤ ì—†ìŒ`);
                // If clicking on empty space while focused, reset the view.
                if (isFocused) {
                    resetCamera();
                }
            }
        }
        
        function onWheel() {
            // Allow zoom/pan even when focused. OrbitControls handles the actual zoom.
        }

        // --- CORE LOGIC FUNCTIONS ---

        function resetCamera() {
            if (cameraTween) cameraTween.kill();
            if (targetTween) targetTween.kill();

            isFocused = false;
            
            // ì§€êµ¬ë³¸ ì™¸ê°ì— í‚¤ì›Œë“œë“¤ì´ ë³´ì´ë„ë¡ ì´ˆê¸° ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì •
            const optimalViewDistance = 150; // ì§€êµ¬ë³¸ ë°˜ì§€ë¦„(80)ì˜ ì•½ 1.9ë°°ë¡œ ì¡°ì •
            const adjustedCameraPosition = new THREE.Vector3(0, 0, optimalViewDistance);
            
            // Animate camera and target back to the initial "globe view"
            gsap.to(camera.position, { 
                duration: 1.2, 
                x: adjustedCameraPosition.x, y: adjustedCameraPosition.y, z: adjustedCameraPosition.z, 
                ease: "power3.inOut",
                onStart: () => { controls.enabled = false; }, // Disable controls during animation
                onComplete: () => { controls.enabled = true; } // Re-enable after
            });
            gsap.to(controls.target, { 
                duration: 1.2, 
                x: 0, y: 0, z: 0, 
                ease: "power3.inOut"
            });

            if(highlightedNode) {
                unhighlightAll();
                highlightedNode = null;
                isHovering = false;
            }
        }

        function searchKeyword() {
            const searchTerm = document.getElementById('keyword-search').value.trim();
            if (!searchTerm) return;
            
            const foundKey = Object.keys(nodes).find(key => key.toLowerCase().includes(searchTerm.toLowerCase()));
            const foundNode = foundKey ? nodes[foundKey] : null;

            if (foundNode) {
                focusOnSet(foundNode);
            } else {
                // Shake animation for feedback
                const searchBox = document.getElementById('search-container');
                searchBox.animate([
                    { transform: 'translateX(0px)' }, { transform: 'translateX(-5px)' }, 
                    { transform: 'translateX(5px)' }, { transform: 'translateX(0px)' }
                ], { duration: 300, iterations: 2 });
            }
        }

        function focusOnSet(centerNode) {
            if (cameraTween) cameraTween.kill();
            if (targetTween) targetTween.kill();

            isFocused = true;
            isHovering = false; // Disable hover state while focused
            
            console.log(`Focusing on keyword: ${centerNode.userData.id}, connections: ${centerNode.userData.connections.size}`);
            
            if (highlightedNode !== centerNode) {
                unhighlightAll();
                highlightedNode = centerNode;
            }
            
            const nodeSet = new Set([centerNode, ...centerNode.userData.connections]);
            highlightSet(nodeSet);

            // --- ê°œì„ ëœ ë°©ì‚¬í˜• ë ˆì´ì•„ì›ƒ: ì¤‘ì‹¬ í‚¤ì›Œë“œì—ì„œ ì¢…ì† í‚¤ì›Œë“œë¡œ ì§ì„  ì—°ê²° ---
            const layoutCenter = new THREE.Vector3(0, 0, 0); // ìƒˆ ë ˆì´ì•„ì›ƒì˜ ì¤‘ì‹¬ì 

            // ì¤‘ì‹¬ ë…¸ë“œë¥¼ ë ˆì´ì•„ì›ƒ ì¤‘ì‹¬ìœ¼ë¡œ ì´ë™
            gsap.to(centerNode.position, {
                duration: 1.0,
                x: layoutCenter.x,
                y: layoutCenter.y,
                z: layoutCenter.z,
                ease: "power2.out",
                onUpdate: () => {
                    updateEdgePositions(centerNode);
                }
            });

            // ì¢…ì† ë…¸ë“œë“¤ì„ ë°©ì‚¬í˜•ìœ¼ë¡œ ë°°ì¹˜ (ê· ë“±í•œ ê°ë„ ë¶„ì‚°)
            const dependentNodes = Array.from(nodeSet).filter(node => node !== centerNode);
            const numDependentNodes = dependentNodes.length;
            
            if (numDependentNodes > 0) {
                // ë™ì  ë°˜ì§€ë¦„: ë…¸ë“œ ìˆ˜ì— ë”°ë¼ ì¡°ì •í•˜ë˜ ê²¹ì¹¨ ë°©ì§€ë¥¼ ìœ„í•´ ì¶©ë¶„í•œ ê°„ê²© í™•ë³´
                const baseRadius = 50; // ê¸°ë³¸ ë°˜ì§€ë¦„ ì¦ê°€
                const radiusIncrement = Math.max(8, numDependentNodes * 1.5); // ë…¸ë“œ ìˆ˜ì— ë”°ë¥¸ ë°˜ì§€ë¦„ ì¦ê°€
                const circleRadius = baseRadius + radiusIncrement;
                
                // ê· ë“±í•œ ê°ë„ ê°„ê²©ìœ¼ë¡œ ë°°ì¹˜
                const angleIncrement = (Math.PI * 2) / numDependentNodes;
                let startAngle = 0; // ì‹œì‘ ê°ë„ (12ì‹œ ë°©í–¥)
                
                dependentNodes.forEach((node, index) => {
                    const angle = startAngle + (angleIncrement * index);
                    const newPosition = new THREE.Vector3(
                        layoutCenter.x + circleRadius * Math.cos(angle),
                        layoutCenter.y + circleRadius * Math.sin(angle),
                        layoutCenter.z // ë™ì¼í•œ Z ë ˆë²¨ ìœ ì§€
                    );
                    
                    gsap.to(node.position, {
                        duration: 1.0,
                        x: newPosition.x,
                        y: newPosition.y,
                        z: newPosition.z,
                        ease: "power2.out",
                        onUpdate: () => {
                            updateEdgePositions(node);
                        }
                    });
                });
                
                console.log(`ë°©ì‚¬í˜• ë ˆì´ì•„ì›ƒ: ${numDependentNodes}ê°œ ë…¸ë“œë¥¼ ë°˜ì§€ë¦„ ${circleRadius}ì— ë°°ì¹˜`);
            }

            // ì¹´ë©”ë¼ í”„ë ˆì´ë°ì„ ìœ„í•œ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
            const boundingRadius = numDependentNodes > 0 ? 
                50 + Math.max(8, numDependentNodes * 1.5) : 30;
            
            // 14ê°œ ì´ìƒ í‚¤ì›Œë“œì˜ ê²½ìš° í†µì¼ëœ ì¹´ë©”ë¼ ì„¤ì •
            let optimalDistance, cameraDirection;
            
            if (numDependentNodes >= 20) {
                // 20-24ê°œ: ì¤Œì•„ì›ƒ ë²„íŠ¼ 2íšŒ ëˆ„ë¥¸ ìƒíƒœ (í™”ë©´ì— ëª¨ë‘ í‘œì‹œ)
                optimalDistance = 120; // ì¤Œì•„ì›ƒ 2íšŒ íš¨ê³¼
                cameraDirection = new THREE.Vector3(0.1, 0.05, 1).normalize(); // ë„“ì€ ì‹œì•¼ê°
                console.log(`ğŸ“º 20-24ê°œ ë…¸ë“œ ê´‘ì‹œì•¼ ì„¤ì •: ${numDependentNodes}ê°œ ë…¸ë“œ â†’ ê±°ë¦¬ ${optimalDistance}, ê´‘ì‹œì•¼ ì•µê¸€ (0.1, 0.05, 1)`);
            } else if (numDependentNodes >= 14) {
                // 14-19ê°œ: ì¤Œì¸ ë²„íŠ¼ 1íšŒ ëˆ„ë¥¸ ìƒíƒœ
                optimalDistance = 85; // ì¤Œì¸ 1íšŒ íš¨ê³¼
                cameraDirection = new THREE.Vector3(0.2, 0.1, 1).normalize(); // ì§‘ì¤‘ ì‹œì•¼ê°
                console.log(`ğŸ¯ 14-19ê°œ ë…¸ë“œ ì§‘ì¤‘ ì„¤ì •: ${numDependentNodes}ê°œ ë…¸ë“œ â†’ ê±°ë¦¬ ${optimalDistance}, ì§‘ì¤‘ ì•µê¸€ (0.2, 0.1, 1)`);
            } else {
                // 13ê°œ ì´í•˜: ê¸°ì¡´ ì ì‘í˜• ë¡œì§ ìœ ì§€
                optimalDistance = 95; // ê¸°ë³¸ í¬ì»¤ì‹± ê±°ë¦¬
                cameraDirection = new THREE.Vector3(0.3, 0.15, 1).normalize(); // ê¸°ì¡´ ì•µê¸€
                
                if (numDependentNodes >= 10) {
                    // 10-13ê°œì¼ ë•Œ: ê¸°ì¡´ ë°©ì‹ ìœ ì§€
                    const extraDistance = (numDependentNodes - 10) * 6.4; 
                    optimalDistance = 95 + extraDistance + 23; 
                    console.log(`ğŸ“ 10-13ê°œ ë…¸ë“œ ê¸°ë³¸ ê±°ë¦¬: ${numDependentNodes}ê°œ ë…¸ë“œ â†’ ${optimalDistance} ê±°ë¦¬`);
                }
            }
            const newCameraPos = layoutCenter.clone().add(cameraDirection.multiplyScalar(optimalDistance));

            console.log(`=== ë°©ì‚¬í˜• í¬ì»¤ì‹± ë””ë²„ê¹… ===`);
            console.log(`ë„¤íŠ¸ì›Œí¬ í¬ê¸°: ${nodeSet.size}ê°œ (ì¤‘ì‹¬: 1, ì¢…ì†: ${numDependentNodes})`);
            console.log(`ë ˆì´ì•„ì›ƒ ë°˜ì§€ë¦„: ${boundingRadius}`);
            console.log(`ìµœì  ì¹´ë©”ë¼ ê±°ë¦¬: ${optimalDistance}`);
            console.log(`ìƒˆ ì¹´ë©”ë¼ ìœ„ì¹˜:`, newCameraPos);
            console.log(`========================`);

            // ì¹´ë©”ë¼ ì• ë‹ˆë©”ì´ì…˜
            cameraTween = gsap.to(camera.position, {
                duration: 1.5, 
                x: newCameraPos.x, 
                y: newCameraPos.y, 
                z: newCameraPos.z, 
                ease: "power3.inOut",
                onStart: () => { controls.enabled = false; },
                onComplete: () => { controls.enabled = true; }
            });
            
            // ì¹´ë©”ë¼ íƒ€ê²Ÿ ì• ë‹ˆë©”ì´ì…˜
            targetTween = gsap.to(controls.target, {
                duration: 1.5, 
                x: layoutCenter.x, 
                y: layoutCenter.y, 
                z: layoutCenter.z, 
                ease: "power3.inOut"
            });
        }
        
        // ì—£ì§€ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í—¬í¼ í•¨ìˆ˜
        function updateEdgePositions(node) {
            edges.forEach(edge => {
                if (edge.userData.nodes.includes(node)) {
                    const start = edge.userData.nodes[0];
                    const end = edge.userData.nodes[1];
                    edge.geometry.setFromPoints([start.position, end.position]);
                }
            });
        }

        function checkHighlight() {
            // This function now only handles hover effects, not focus.
            // It won't run until the user has moved the mouse, ensuring a stable start.
            if (isFocused || !hasUserInteracted) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(hitboxes);

            const newHighlight = intersects.length > 0 ? intersects[0].object.userData.visibleNode : null;

            if (highlightedNode !== newHighlight) {
                if (highlightedNode) {
                    unhighlightAll();
                }
                if (newHighlight) {
                    highlightSet(new Set([newHighlight, ...newHighlight.userData.connections]));
                }
                highlightedNode = newHighlight;
            }
            
            // Update hover state, which controls rotation in the animate loop.
            isHovering = !!newHighlight;
        }

        function highlightSet(nodeSet) {
            Object.values(nodes).forEach(n => {
                const isHighlighted = nodeSet.has(n);
                // 2D í¬ì»¤ì‹± ëª¨ë“œì—ì„œëŠ” ë°°ê²½ì„ ë” ì–´ë‘¡ê²Œ ì²˜ë¦¬
                const backgroundOpacity = isFocused ? 0.02 : 0.05;
                n.material.opacity = isHighlighted ? 1.0 : backgroundOpacity;
                n.userData.label.element.style.opacity = isHighlighted ? 1.0 : backgroundOpacity;
                
                // 2D í¬ì»¤ì‹± ëª¨ë“œì—ì„œ ë°°ê²½ ë…¸ë“œì˜ ìƒ‰ìƒê³¼ ë°œê´‘ë„ ì–´ë‘¡ê²Œ ì²˜ë¦¬
                if (!isHighlighted && isFocused) {
                    n.material.color.set(0x2d2d2d); // ë°°ê²½ ë…¸ë“œ: ì–´ë‘ìš´ íšŒìƒ‰
                    n.material.emissive.set(0x000000); // ë°œê´‘ ì œê±°
                }
                
                // 2D í¬ì»¤ì‹± ëª¨ë“œì—ì„œ í‚¤ì›Œë“œ ì†ì„±ì— ë”°ë¥¸ ìƒ‰ìƒ ì°¨ë³„í™”
                if (isHighlighted && isFocused) {
                    // ì¤‘ì‹¬ í‚¤ì›Œë“œ (í´ë¦­í•œ í‚¤ì›Œë“œ)ëŠ” ë°ì€ ì˜¤ë Œì§€
                    if (n === highlightedNode) {
                        n.material.color.set(0xff6b35); // ì¤‘ì‹¬ í‚¤ì›Œë“œ: ë°ì€ ì˜¤ë Œì§€
                        n.material.emissive.set(0xff6b35).multiplyScalar(0.4);
                    } else {
                        // ì¢…ì† í‚¤ì›Œë“œë“¤ì€ íŒŒë€ìƒ‰ ê³„ì—´
                        n.material.color.set(0x3b82f6); // ì¢…ì† í‚¤ì›Œë“œ: íŒŒë€ìƒ‰
                        n.material.emissive.set(0x3b82f6).multiplyScalar(0.3);
                    }
                    
                    const currentSize = parseInt(document.getElementById('text-size-slider').value);
                    n.userData.label.element.style.fontSize = (currentSize + 2) + 'px';
                    n.userData.label.visible = true; // í¬ì»¤ì‹±ëœ í‚¤ì›Œë“œëŠ” í•­ìƒ ë¼ë²¨ í‘œì‹œ
                } else if (isHighlighted) {
                    // ì¼ë°˜ í•˜ì´ë¼ì´íŠ¸ ìƒíƒœ (3D ëª¨ë“œ)ì—ì„œëŠ” ê¸°ì¡´ ìƒ‰ìƒ ìœ ì§€
                    const state = Math.random() * 2 - 1; // ê¸°ì¡´ ìƒíƒœê°’ ì‚¬ìš©
                    const originalColor = getStateColor(state);
                    n.material.color.copy(originalColor);
                    n.material.emissive.copy(originalColor).multiplyScalar(0.3);
                }
            });

            edges.forEach(edge => {
                const [start, end] = edge.userData.nodes;
                const isHighlighted = nodeSet.has(start) && nodeSet.has(end);
                
                if (isHighlighted) {
                    // 2D í¬ì»¤ì‹± ëª¨ë“œì—ì„œ ì—°ê²°ì„  ìƒ‰ìƒ ë‹¤ì–‘í™”
                    if (isFocused) {
                        // ì¤‘ì‹¬ í‚¤ì›Œë“œì™€ ì—°ê²°ëœ ì„ ì€ ì˜¤ë Œì§€ê³„ì—´
                        if (start === highlightedNode || end === highlightedNode) {
                            edge.material.color.set(0xff8c42); // ì¤‘ì‹¬-ì¢…ì† ì—°ê²°: ì£¼í™©ìƒ‰
                        } else {
                            // ì¢…ì† í‚¤ì›Œë“œë“¤ ê°„ ì—°ê²°ì€ ì²­ë¡ìƒ‰
                            edge.material.color.set(0x06b6d4); // ì¢…ì†-ì¢…ì† ì—°ê²°: ì²­ë¡ìƒ‰
                        }
                        edge.material.opacity = 0.9; // 2D ëª¨ë“œì—ì„œ ë” ì„ ëª…í•˜ê²Œ
                    } else {
                        // 3D ëª¨ë“œì—ì„œëŠ” ê¸°ì¡´ ë…¸ë€ìƒ‰ ìœ ì§€
                        edge.material.color.set(0xfbbf24);
                        edge.material.opacity = 0.8;
                    }
                } else {
                    edge.material.color.set(0x4b5563);
                    edge.material.opacity = isFocused ? 0.01 : 0.02; // 2D ëª¨ë“œì—ì„œ ë°°ê²½ ì—°ê²°ì„  ë” ì–´ë‘¡ê²Œ
                }
            });
        }

        function unhighlightAll() {
             Object.values(nodes).forEach(n => {
                n.material.opacity = 1;
                n.userData.label.element.style.opacity = 1;
                
                // ì›ë˜ ìƒ‰ìƒìœ¼ë¡œ ë³µì› (ìƒíƒœ ê¸°ë°˜)
                if (n.userData.originalState !== undefined) {
                    const originalColor = getStateColor(n.userData.originalState);
                    n.material.color.copy(originalColor);
                    n.material.emissive.copy(originalColor).multiplyScalar(0.3);
                }
                
                // í…ìŠ¤íŠ¸ í¬ê¸°ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µì› (í…ìŠ¤íŠ¸ í¬ê¸° ìŠ¬ë¼ì´ë” ê°’ ì‚¬ìš©)
                const defaultSize = document.getElementById('text-size-slider').value;
                n.userData.label.element.style.fontSize = defaultSize + 'px';

                // ë…¸ë“œë¥¼ ì›ë˜ ìœ„ì¹˜ë¡œ ë˜ëŒë¦¼
                gsap.to(n.position, {
                    duration: 1.0, // Animation duration
                    x: n.userData.originalPosition.x,
                    y: n.userData.originalPosition.y,
                    z: n.userData.originalPosition.z,
                    ease: "power2.out"
                });
            });
            edges.forEach(edge => {
                edge.material.color.set(0x4b5563);
                edge.material.opacity = 0.15;
            });
        }

        // ì„±ëŠ¥ ìµœì í™” ë³€ìˆ˜ë“¤
        let frameCount = 0;
        const OPTIMIZATION_FRAME_SKIP = 3; // 3í”„ë ˆì„ë§ˆë‹¤ ì—…ë°ì´íŠ¸
        
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            
            // Centralized rotation control. Rotates only when not focused and not hovering.
            controls.autoRotate = !isFocused && !isHovering;

            // ì„±ëŠ¥ ìµœì í™”: ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ ë¹ˆë„ ì¡°ì ˆ
            if (frameCount % OPTIMIZATION_FRAME_SKIP === 0) {
                const time = Date.now() * 0.002;
                
                // ê°œì„ ëœ ì ì‘í˜• LOD ì‹œìŠ¤í…œ: ì¤Œ ë ˆë²¨ì— ë”°ë¼ ì¤‘ì•™/ì™¸ê³½ ìš°ì„  í‘œì‹œ ì „í™˜
                if (!isFocused) {
                    const cameraPosition = camera.position;
                    const cameraDistance = cameraPosition.length(); // ì›ì ì—ì„œ ì¹´ë©”ë¼ê¹Œì§€ì˜ ê±°ë¦¬
                    const sphereRadius = 80; // ì§€êµ¬ë³¸ ë°˜ì§€ë¦„
                    
                    // ì¤Œ ë ˆë²¨ íŒë‹¨: ì§€êµ¬ë³¸ ë°˜ì§€ë¦„ ëŒ€ë¹„ ì¹´ë©”ë¼ ê±°ë¦¬
                    const zoomRatio = cameraDistance / sphereRadius;
                    const isZoomedIn = zoomRatio < 2.0; // 2.0ë°° ë¯¸ë§Œì´ë©´ ì¤Œì¸ ìƒíƒœ (ë” ë„“ì€ ë²”ìœ„)
                    
                    // ì¹´ë©”ë¼ ë°©í–¥ ë²¡í„°
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    
                    Object.values(nodes).forEach(node => {
                        if (node.userData.isNode) {
                            const distance = cameraPosition.distanceTo(node.position);
                            const centerDistance = node.position.length(); // ì›ì ì—ì„œ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬
                            
                            // ì‹œì•¼ê° ë‚´ ì—¬ë¶€ íŒë‹¨ (ì¹´ë©”ë¼ ë°©í–¥ê³¼ ë…¸ë“œ ë°©í–¥ì˜ ê°ë„)
                            const nodeDirection = node.position.clone().sub(cameraPosition).normalize();
                            const viewAngle = Math.acos(cameraDirection.dot(nodeDirection));
                            const isInViewAngle = viewAngle < Math.PI / 3; // 60ë„ ì‹œì•¼ê° ë‚´
                            
                            if (isZoomedIn) {
                                // ì¤Œì¸ ìƒíƒœ: ì¤‘ì•™ í‚¤ì›Œë“œ ìš°ì„  í‘œì‹œ
                                const isCentralNode = centerDistance < sphereRadius * 0.9; // ì§€êµ¬ë³¸ ë‚´ë¶€ 90% ì˜ì—­ (í™•ëŒ€)
                                
                                if (isCentralNode) {
                                    // ì¤‘ì•™ ë…¸ë“œ: í•­ìƒ ì™„ì „íˆ ë³´ì„ (ì‹œì•¼ê° ë¬´ê´€)
                                    node.userData.label.visible = true;
                                    node.material.opacity = 1.0;
                                    const scale = 1 + Math.sin(time + node.userData.waveOffset) * 0.05;
                                    node.scale.set(scale, scale, scale);
                                } else if (isInViewAngle && distance < 120) {
                                    // ì™¸ê³½ì´ì§€ë§Œ ì‹œì•¼ê° ë‚´ì´ê³  ê°€ê¹Œìš´ ë…¸ë“œ: íë¦¿í•˜ê²Œ ë³´ì„
                                    node.userData.label.visible = distance < 100;
                                    node.material.opacity = 0.4;
                                    const scale = 1 + Math.sin(time + node.userData.waveOffset) * 0.02;
                                    node.scale.set(scale, scale, scale);
                                } else {
                                    // ì™¸ê³½ ë…¸ë“œ: ê±°ì˜ ì•ˆë³´ì„
                                    node.userData.label.visible = false;
                                    node.material.opacity = 0.1;
                                    node.scale.set(0.7, 0.7, 0.7);
                                }
                            } else {
                                // ì¤Œì•„ì›ƒ ìƒíƒœ: ì™¸ê³½ í‚¤ì›Œë“œ ìš°ì„  í‘œì‹œ (ê¸°ì¡´ ë°©ì‹)
                                const isOuterNode = centerDistance > sphereRadius * 0.9; // ì§€êµ¬ë³¸ ì™¸ë¶€ 90% ì˜ì—­
                                
                                if (isOuterNode && isInViewAngle && distance < 150) {
                                    // ì™¸ê³½ì˜ ì‹œì•¼ê° ë‚´ ë…¸ë“œ: ì™„ì „íˆ ë³´ì„
                                    node.userData.label.visible = true;
                                    node.material.opacity = 1.0;
                                    const scale = 1 + Math.sin(time + node.userData.waveOffset) * 0.05;
                                    node.scale.set(scale, scale, scale);
                                } else if (distance < 200) {
                                    // ì¤‘ê°„ ê±°ë¦¬: íë¦¿í•˜ê²Œ ë³´ì„
                                    node.userData.label.visible = distance < 120;
                                    node.material.opacity = Math.max(0.3, 1 - (distance / 200));
                                    const scale = 1 + Math.sin(time + node.userData.waveOffset) * 0.02;
                                    node.scale.set(scale, scale, scale);
                                } else {
                                    // ë©€ë¦¬ ìˆëŠ” ë…¸ë“œ: ê±°ì˜ ì•ˆë³´ì„
                                    node.userData.label.visible = false;
                                    node.material.opacity = Math.max(0.1, 1 - (distance / 300));
                                    node.scale.set(1, 1, 1);
                                }
                            }
                        }
                    });
                } else {
                    // í¬ì»¤ì‹± ìƒíƒœì¼ ë•ŒëŠ” ëª¨ë“  ë…¸ë“œ ì™„ì „ í‘œì‹œ
                    Object.values(nodes).forEach(node => {
                        if (node.userData.isNode) {
                            node.userData.label.visible = true;
                            node.material.opacity = 1.0;
                            const scale = 1 + Math.sin(time + node.userData.waveOffset) * 0.05;
                            node.scale.set(scale, scale, scale);
                        }
                    });
                }
            }

            // í•˜ì´ë¼ì´íŠ¸ ì²´í¬ëŠ” ë§¤ í”„ë ˆì„ (ìƒí˜¸ì‘ìš© ë°˜ì‘ì„± ìœ ì§€)
            checkHighlight();
            controls.update();
            
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }
    </script>
</body>
</html>